#TITLE:Go, практика асинхронного взаимодействия

      Немножко про каналы, про выполнение в основном процессе, про то как вынести блокирующие операции в отдельную горутину.Каналы и пустое значение
Односторонние каналы
Выполнение в основном процессе
Вынос блокирующих операций
Каналы и пустое значение
Каналы — это инструмент для асинхронной разработки. Но зачастую не важно что переслать по каналу — важен лишь факт пересылки. Порой встречаетсяdone := make(chan bool)/// [...]
done &lt;- true
Размер bool зависит от платформы, да, обычно, это не тот случай, когда следует беспокоиться о размере. Но всё же существует способ ничего не отправлять, а если точнее — то отправлять ничего (если быть ещё точнее, то речь о пустой структуре).done := make(chan struct{})// [...]
done &lt;- struct{}{}
Вот собственно и всё.Односторонние каналы
Есть ещё один момент, который хотелось бы явно осветить. Пример:func main() {
    done := make(chan struct{})
    go func() {
        // stuff
        done &lt;- struct{}
    }()
    &lt;- done}
Всё просто — done в горутине нужен только для записи. В принципе, в горутине его можно и прочитать (получить значение из канала done). Во избежании неприятностей, если код путаный, выручают параметры. Параметры функции, что передаётся горутине. Теперь такfunc main() {
    done := make(chan struct{})
    go func(done chan&lt;- struct{}) {
        // stuff
        done &lt;- struct{}
    } (done)
    &lt;- done}Теперь, при передаче канала так, он будет преобразован в канал только для записи. Но вот внизу, канал по прежнему останется двунаправленным. В принципе, канал можно преобразовать в односторонний и не передавая его аргументом: done := make(chan struct{})
writingChan := (chan&lt;- struct{})(done) // первые скобки не важны
readingChan := (&lt;-chan struct{})(done) // первые скобки обязательны При частой необходимости, можно сделать функцию, которая будет всем этим заниматься. Вот пример на play.golang.org. Всё это позволяет отловить некоторые ошибки на этапе компиляции.Выполнение в основном процессе
Например такие библиотеки как — OpenGL, libSDL, Cocoa — используют локальные для процесса структуры данных (thread local storage). Это значит, что они должны выполняться в основном процессе (main thread) ОС, иначе — ошибка. Функция runtime.LockOSThread() позволяет приморозить текущую горутину к текущему процессу ОС. Если вызвать её при инициализации (в функции init), то это и будет основной процесс ОС. При этом другие горутины спокойно могут выполняться в параллельных процессах.
Для того, чтобы вынести вычисления в отдельный процесс достаточно просто пересылать функции в основной. Вот и всё.ПростыняНа play.golang.orgpackage main
 import (
        "fmt"
        "runtime")
 
func init() {
        runtime.LockOSThread() // примораживаем текущую горутину к текущему процессу}
 
func main() {
        /*
            коммуникации
        */
        done := make(chan struct{})    // &lt;- остановка и выход
        stuff := make(chan func()) // &lt;- отправка функций в основной процесс
 
        /*
            создадим второй процесс (в данном случае - вторую горутину, но  это не важно)
            и начнём отправлять "работу" в первый
        */
        go func(done chan&lt;- struct{}, stuff chan&lt;- func()) { // параллельный процесс
                stuff &lt;- func() { // первый пошёл
                        fmt.Println("1")
                }
                stuff &lt;- func() { // второй пошёл
                        fmt.Println("2")
                }
                stuff &lt;- func() { // третий пошёл
                        fmt.Println("3")
                }
                done &lt;- struct{}{}
        }(done, stuff)
Loop:
        for {
                select {
                case do := &lt;-stuff: // получение "работы"
                        do()        // и выполнение
                case &lt;-done:
                        break Loop
                }
        }}Вынос блокирующих операций
Куда чаще встречаются блокирующие IO-операции, но они побеждаются аналогично.ПростыняНа play.golang.orgpackage main
 import "os"
 
func main() {
        /*
                коммуникации
        */
        stop := make(chan struct{}) // нужен для остановки "пишущей" горутины
        done := make(chan struct{}) // ожидание её завершения
        write := make(chan []byte) // данные для записи
 
        /*
                параллельный поток для IO-операций
        */
        go func(write &lt;-chan []byte, stop &lt;-chan struct{}, done chan&lt;- struct{}) {
        Loop:
                for {
                        select {
                        case msg := &lt;-write: // получения сообщения для записи
                                os.Stdout.Write(msg) // асинхронная запись
                        case &lt;-stop:
                                break Loop
                        }
                }
                done &lt;- struct{}{}
        }(write, stop, done)
        write &lt;- []byte("Hello ")    // отправка сообщений
        write &lt;- []byte("World!\n")  // на запись
        stop &lt;- struct{}{} // остановка
        &lt;-done // ожидание завершения}Если несколько горутин будут отправлять свои сообщения к одной «пишущей», то они всё равно будут блокироваться. В этом случае выручит канал с буфером. Учитывая, что slice — это референсный тип, по каналу будет пересылаться только указатель.РеференсРазъяснение LockOSThread (англ.)
Пустые структуры на blog.golang.org (англ.)
Ещё про пустые структуры (англ.)

		

	

		Материал

		
					


				
					ничего нового
				
			
					


				
					50/50
				
			
					


				
					норм
				
			Проголосовало 24 человека. Воздержалось 14 человек.
	

    Только зарегистрированные пользователи могут участвовать в опросе. Войдите, пожалуйста.
	

      
    