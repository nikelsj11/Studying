#TITLE:Реализация многопоточной архитектуры игрового движка

      С появлением многоядерных процессоров возникла необходимость в создании игрового движка на основе параллельной архитектуры. Использование всех процессоров системы — как графического (ГП), так и центрального (ЦП) — открывает гораздо больше возможностей по сравнению с однопоточным движком на базе только ГП. Например, используя больше ядер ЦП, можно улучшить визуальные эффекты, увеличив количество физических объектов, используемых в игре, а также добиться более реалистичного поведения персонажей за счет реализации продвинутого искусственного интеллекта (ИИ).
Рассмотрим особенности реализации многопоточной архитектуры игрового движка.1. Введение1.1. Обзор
Многопоточная архитектура игрового движка позволяет использовать возможности всех процессоров платформы по максимуму. Она предполагает параллельное выполнение различных функциональных блоков на всех доступных процессорах. Однако реализовать подобную схему, оказывается, не так просто. Отдельные элементы игрового движка часто взаимодействуют между собой, что может привести к появлению ошибок при одновременном их выполнении. Для обработки подобных сценариев в движке предусмотрены специальные механизмы синхронизации данных, исключающие возможные блокировки. В нем также реализованы методы одновременной синхронизации данных, за счет чего время выполнения удается свести к минимуму.
Для понимания представленных материалов нужно хорошо разбираться в современных методах создания компьютерных игр, поддержки многопоточности для игровых движков или для улучшения производительности приложений в целом.2. Состояние параллельного выполнения
Состояние параллельного выполнения — это ключевое понятие многопоточности. Только разделив игровой движок на отдельные системы, работающие каждая в своем режиме и практически не взаимодействующие с остальной частью движка, можно добиться наибольшей эффективности параллельных вычислений и сократить время, необходимое на синхронизацию. Полностью изолировать отдельные части движка, исключив все общие ресурсы, не представляется возможным. Однако для таких операций, как получение данных о положении или ориентации объектов, отдельные системы могут использовать локальные копии данных, а не общие ресурсы. Это позволяет свести к минимуму зависимость данных в различных частях движка. Уведомления об изменениях общих данных, выполненных отдельной системой, передаются менеджеру состояний, который помещает их в очередь. Это называется режимом обмена сообщениями. Данный режим предполагает, что, завершив выполнение задач, системы движка получают уведомления об изменениях и соответствующим образом обновляют свои внутренние данные. Такой механизм позволяет значительно сократить время синхронизации и зависимости систем друг от друга.2.1 Состояния выполнения
Чтобы менеджер состояний выполнения работал эффективно, рекомендуется синхронизировать операции по определенному тактовому импульсу. Это позволяет всем системам работать одновременно. При этом частота тактов не обязательно должна соответствовать частоте передачи кадров. Да и длительность тактов может не зависеть от частоты. Ее можно выбрать таким образом, чтобы один такт соответствовал времени, необходимому на передачу одного кадра (вне зависимости от его размера). Иными словами, частоту или длительность тактов определяет конкретная реализация менеджера состояний. На рисунке 1 показан «свободный» пошаговый режим работы, в котором не требуется, чтобы все системы завершали выполнение операции за один и тот же такт. Режим, при котором все системы завершают выполнение операций за один такт, называется «жестким» пошаговым режимом. Он схематично изображен на рисунке 2.Рисунок 1. Состояние выполнения в свободном пошаговом режиме2.1.1. Свободный пошаговый режим
В свободном пошаговом режиме все системы работают непрерывно в течение заранее заданного промежутка времени, необходимого для завершения очередной порции вычислений. Однако название «свободный» не следует понимать буквально: системы синхронизируются не в произвольный момент времени, они лишь «свободны» в выборе числа тактов, необходимого на выполнение очередного этапа.
Как правило, в этом режиме недостаточно отправить менеджеру состояний простое уведомление об изменении состояния. Необходимо также передать обновленные данные. Это вызвано тем, что система, которая изменила общие данные, может находиться в состоянии выполнения, в то время как другая система, ожидающая эти данные, уже готова выполнить обновление. В этом случае требуется больше памяти, так как нужно создавать больше копий данных. Поэтому «свободный» режим нельзя считать универсальным решением на все случаи жизни.2.1.2. Жесткий пошаговый режим
В этом режиме выполнение задач всех систем завершается за один такт. Такой механизм проще в реализации и не требует передачи обновленных данных вместе с уведомлением. Действительно, при необходимости одна система может просто запросить новые значения у другой системы (разумеется, в конце цикла выполнения).
В жестком режиме можно реализовать псевдосвободный пошаговый режим работы, распределяя вычисления между различными шагами. В частности, это может потребоваться для расчетов ИИ, где за первый такт вычисляется начальная «общая цель», которая постепенно уточняется на следующих этапах.Рисунок 2. Состояние выполнения в жестком пошаговом режиме2.2. Синхронизация данных
Изменение общих данных несколькими системами может привести к конфликту изменений. На этот случай в системе обмена сообщениями необходимо предусмотреть алгоритм выбора правильного итогового значения. Существует два основных подхода, основанных на следующих критериях.Время: итоговым значением становится последнее внесенное изменение.
Приоритет: итоговым значением становится изменение, выполненное системой с наибольшим приоритетом. Если приоритет систем совпадает, можно также учитывать время внесения изменений.

Все устаревшие данные (по любому из критериев) можно просто перезаписать или исключить из очереди уведомлений.
Поскольку итоговое значение может зависеть от порядка внесения изменений, использовать относительные значения общих данных может оказаться очень сложно. В таких случаях следует использовать абсолютные значения. Тогда при обновлении локальных данных системы могут просто заменить старые значения новыми. Оптимальное решение — выбирать абсолютные или относительные значения в зависимости от конкретной ситуации. Например, общие данные, такие как положение и ориентация, должны иметь абсолютные значения, поскольку для них важен порядок внесения изменений. Относительные значения можно использовать, к примеру, для системы генерации частиц, поскольку вся информация о частицах хранится только в ней самой.3. Движок
При разработке движка основное внимание уделяется гибкости, необходимой для дальнейшего расширения его функциональности. Это позволит оптимизировать его для использования в условиях определенных ограничений (например, по памяти).
Движок можно условно разделить на две части: фреймворк и менеджеры. Фреймворк (см. раздел 3.1) включает в себя части игры, которые тиражируются в процессе выполнения, то есть существуют в нескольких экземплярах. В него также входят элементы, участвующие в выполнении основного цикла игры. Менеджеры (см. раздел 3.2) представляют собой Singleton-объекты, отвечающие за выполнение логической составляющей игры.
Ниже представлена схема игрового движка.Рисунок 3. Общая архитектура движка
Обратите внимание, что функциональные игровые модули, или системы, не являются частью движка. Движок лишь объединяет их между собой, выступая в роли связующего элемента. Подобная модульная организация дает возможность загружать и выгружать системы по мере необходимости.
Взаимодействие движка и систем осуществляется при помощи интерфейсов. Они реализованы таким образом, чтобы предоставить движку доступ к функциям систем, а системам — к менеджерам движка.
Подробная схема движка представлена в приложении A, «Схема движка».
Фактически все системы независимы друг от друга (см. раздел 2, «Состояние одновременного выполнения»), то есть они могут выполнять действия параллельно, не влияя на работу других систем. Однако любое изменение данных повлечет за собой определенные сложности, поскольку системам придется взаимодействовать между собой. Обмен информацией между системами необходим в следующих случаях:чтобы сообщить другой системе об изменении общих данных (например, положения или ориентации объектов);
чтобы выполнить функции, недоступные для данной системы (например, система ИИ обращается к системе расчета геометрических или физических свойств объекта, чтобы выполнить тест на пересечение лучей).

В первом случае для управления обменом информацией можно использовать менеджер состояний, описанный в предыдущем разделе. (Подробнее о менеджере состояний см. в разделе 3.2.2, «Менеджер состояний».)
Во втором случае необходимо реализовать специальный механизм, который позволит предоставить службы одной системы для использования другой. Полное описание этого механизма приведено в разделе 3.2.3, «Менеджер служб».3.1. Фреймворк
Фреймворк служит для объединения всех элементов движка. В нем происходит инициализация движка, за исключением менеджеров, экземпляры которых создаются глобально. В нем также хранится информация о сцене. Чтобы добиться большей гибкости, сцена реализуется в виде так называемой универсальной сцены, которая содержит универсальные объекты. Они представляют собой контейнеры, объединяющие различные функциональные части сцены. Подробная информация приведена в разделе 3.1.2.
Основной цикл игры также реализован во фреймворке. Схематично его можно представить следующим образом.Рисунок 4. Основной цикл игры
Движок работает в оконной среде, поэтому на первом шаге цикла игры необходимо обработать все незавершенные сообщения окон ОС. Если этого не сделать, движок не будет реагировать на сообщения ОС. На втором шаге планировщик назначает задачи с помощью менеджера задач. Этот процесс подробно описан в разделе 3.1.1 ниже. После этого менеджер состояний (см. раздел 3.2.2) рассылает информацию о выполненных изменениях системам движка, на работу которых она может повлиять. На последнем шаге, в зависимости от статуса выполнения, фреймворк определяет, следует ли завершить или продолжить работу движка, например, для перехода к следующей сцене. Информация о состоянии движка хранится у менеджера среды. Подробнее см. в разделе 3.2.4.3.1.1. Планировщик
Планировщик генерирует опорный тактовый сигнал выполнения с заданной частотой. Если в режиме эталонного тестирования требуется, чтобы следующая операция начиналась сразу после завершения предыдущей, не дожидаясь окончания такта, частота может быть неограниченной.
По тактовому сигналу планировщик с помощью менеджера задач переводит системы в режим выполнения. В свободном пошаговом режиме (раздел 2.1.1) планировщик опрашивает системы, чтобы определить, сколько тактов им понадобится на завершение задачи. По результатам опроса планировщик определяет, какие системы готовы к выполнению, а какие завершат работу в конкретный такт. Планировщик может изменить количество тактов, если какой-либо системе требуется больше времени на выполнение. В жестком пошаговом режиме (раздел 2.1.2) все системы начинают и заканчивают выполнение в один и тот же такт, поэтому планировщик ждет, когда завершится выполнение всех систем.3.1.2. Универсальная сцена и объекты
Универсальная сцена и объекты являются контейнерами для функциональности, реализованной в других системах. Они предназначены исключительно для взаимодействия с движком и не выполняют никаких других функций. Однако их можно расширить, чтобы использовать функции, доступные другим системам. Это позволяет добиться слабой связанности. Действительно, универсальная сцена и объекты могут использовать свойства других систем, не будучи привязанными к ним. Именно это свойство исключает зависимость систем друг от друга и дает им возможность работать одновременно.
На схеме ниже изображено расширение универсальной сцены и объекта.Рисунок 5. Расширение универсальной сцены и объекта
Рассмотрим принцип работы расширений на следующем примере. Допустим, выполнено расширение универсальной универсальная сцены сцена расширена на для использование использования графических, физических и других свойств. В этом случае за инициализацию дисплея будет отвечать «графическая» часть расширения, а за реализацию физических законов для твердых тел, например силы тяжести, — его «физическая» часть. Сцены содержат объекты, поэтому универсальная сцена тоже будет включать в себя несколько универсальных объектов. Универсальные объекты также можно расширить намогут быть расширены для использование использования графических, физических и других свойств. Например, прорисовка объекта на экране будет реализована графическими функциями расширения, а расчет взаимодействия твердых тел — физическими.
Подробная схема взаимодействия движка и систем приведена в приложении B, «Схема взаимодействия движка и систем».
Следует заметить, что универсальная сцена и универсальный объект отвечают за регистрацию всех своих «расширений» в менеджере состояний, для того, чтобы все расширения могли получать уведомления об изменениях, внесенных другими расширениями (то есть другими системами). В качестве примера можно привести графическое расширение, зарегистрированное для получения уведомлений об изменениях положения и ориентации, выполненных физическим расширением.
Подробную информацию о компонентах системы см. в разделе 5.2, «Компоненты системы».3.2. Менеджеры
Менеджеры управляют работой движка. Они являются Singleton-объектами, то есть менеджер каждого типа доступен только в одном экземпляре. Это необходимо, поскольку дублирование ресурсов менеджеров неизбежно приведет к избыточности и отрицательно скажется на производительности. Кроме того, менеджеры отвечают за реализацию общих функций для всех систем.3.2.1. Менеджер задач
Менеджер задач отвечает за управление системными задачами в пуле потоков. Чтобы обеспечить оптимальное n-кратное масштабирование и предотвратить назначение лишних потоков, исключая неоправданные издержки на переключение задач в операционной системе, пул потоков создает по одному потоку на каждый процессор.
Планировщик передает менеджеру задач список задач для выполнения, а также информацию о том, завершения каких задач необходимо дождаться. Он получает эти данные от различных систем. Каждая система получает только одну задачу для выполнения. Такой метод называют функциональной декомпозицией. Однако для обработки данных каждую такую задачу можно разделить на произвольное количество подзадач (декомпозиция данных).
Ниже приведен пример распределения задач между потоками для четырехъядерной системы.Рисунок 6. Пример пула потоков, используемого менеджером задач
Помимо обработки запросов планировщика по доступу к основным задачам менеджер задач может работать в режиме инициализации. Он последовательно опрашивает системы от каждого потока, чтобы они могли инициализировать локальные хранилища данных, необходимые для работы.
Советы по реализации менеджера задач даны в приложении D, «Советы по реализации задач».3.2.2. Менеджер состояний
Менеджер состояний является частью механизма обмена сообщениями. Он отслеживает изменения и рассылает уведомления о них всем системам, которых эти изменения могут затронуть. Чтобы не рассылать ненужных уведомлений, менеджер состояний хранит информацию о том, какие системы оповещать в том или ином случае. Этот механизм реализован на основе шаблона «Наблюдатель» (см. приложение C, «Наблюдатель (шаблон проектирования)»). Если говорить вкратце, данный шаблон предполагает использование «наблюдателя», который следит за любыми изменениями субъекта, при этом роль посредника между ними выполняет контроллер изменений.
Механизм работает следующим образом. 1. Наблюдатель сообщает контроллеру изменений (или менеджеру состояний), изменения каких субъектов он хочет отслеживать. 2. Субъект уведомляет контроллер обо всех своих изменениях. 3. По сигналу фреймворка контроллер оповещает наблюдателя об изменениях субъекта. 4. Наблюдатель отправляет субъекту запрос на получение обновленных данных.
В режиме свободного пошагового выполнения (см. раздел 2.1.1) реализация этого механизма несколько усложняется. Во-первых, обновленные данные придется отправлять вместе с уведомлением об изменении. В этом режиме отправка по запросу неприменима. Действительно, если на момент получения запроса система, ответственная за изменения, еще не закончит выполнение, она не сможет предоставить обновленные данные. Во-вторых, если какая-то система еще не готова получить изменения в конце такта, менеджер состояний должен будет удерживать измененные данные до тех пор, пока все зарегистрированные для их получения системы не придут в состояние готовности.
Во фреймворке для этого предусмотрено два менеджера состояний: для обработки изменений на уровне сцены и на уровне объекта. Обычно сообщения, касающиеся сцен и объектов, независимы друг от друга, поэтому использование двух отдельных менеджеров исключает необходимость обработки ненужных данных. Но если в сцене необходимо учитывать состояние какого-либо объекта, ее можно зарегистрировать на для получение получения уведомлений о его изменениях.
Чтобы не выполнять лишней синхронизации, менеджер состояний формирует очередь уведомлений об изменениях отдельно для каждого потока, создаваемого менеджером задач. Поэтому при доступе к очереди никакой синхронизации не требуется. В разделе 2.2 описан метод, который можно использовать для объединения очередей после выполнения.Рисунок 7. Уведомление о внутренних изменениях универсального объекта
Уведомления об изменениях не обязательно рассылать последовательно. Существует способ их параллельной рассылки. Выполняя задачу, система работает со всеми своими объектами. Например, по мере того как физические объекты взаимодействуют друг с другом, физическая система управляет их перемещением, расчетом столкновений, новых действующих сил и т. п. При получении уведомлений объект системы не взаимодействует с другими объектами своей системы. Он взаимодействует со связанными с ним расширениями универсального объекта. Это означает, что универсальные объекты теперь независимы друг от друга и их можно обновить одновременно. Такой подход не исключает крайних случаев, которые следует учитывать в процессе синхронизации. Однако он позволяет использовать режим параллельного выполнения, когда казалось, что действовать можно только последовательно.3.2.3. Менеджер служб
Менеджер служб предоставляет системам доступ к функциям других систем, которые иначе были бы им недоступны. Важно понимать, что доступ к функциям осуществляется с помощью интерфейсов, а не напрямую. Информация об интерфейсах систем также хранится в менеджере служб.
Чтобы исключить зависимости систем друг от друга, каждая из них обладает лишь небольшим набором служб. Кроме того, возможность использования той или иной службы определяется не самой системой, а менеджером служб.Рисунок 8. Пример менеджера служб
У менеджера служб есть и другая функция. Он предоставляет системам доступ к свойствам других систем. Свойствами называются специфичные значения конкретных систем, которые не передаются в системе обмена сообщениями. Это может быть расширение разрешение экрана в графической системе или величина силы тяжести в физической. Менеджер служб открывает системам доступ к таким данным, но не позволяет напрямую их контролировать. Он помещает изменения свойств в специальную очередь и публикует их только после последовательного выполнения. Обратите внимание, что доступ к свойствам другой системы требуется достаточно редко и не стоит им злоупотреблять. Например, он может понадобиться для включения и отключения режима каркасной сетки в графической системе из окна консоли или для изменения разрешения экрана по запросу игрока из интерфейса пользователя. Данную возможность преимущественно используют для установки параметров, которые не изменяются от кадра к кадру.3.2.4. Менеджер средыМенеджер среды обеспечивает работу среды выполнения движка. Его функции условно можно разделить на следующие группы.
Переменные: имена и значения общих переменных, используемых всеми частями движка. Обычно значения переменных определяются при загрузке сцены или определенных пользовательских настроек. Движок и различные системы могут получить к ним доступ, отправив соответствующий запрос.
Выполнение: данные о выполнении, например о завершении выполнения сцены или программы. Эти параметры могут устанавливать и запрашивать как сами системы, так и движок.
3.2.5. Менеджер платформы
Менеджер платформы реализует абстракцию для вызовов операционной системы, а также обеспечивает дополнительную функциональность помимо простой абстракции. Преимуществом такого подхода является инкапсуляция нескольких типичных функций в рамках одного вызова. То есть их не придется реализовывать отдельно для каждого вызывающего элемента, перегружая его подробностями о вызовах ОС.
Рассмотрим в качестве примера вызов менеджера платформы для загрузки динамической библиотеки системы. Он не только загружает систему, но также получает точки входа функции и вызывает функцию инициализации библиотеки. Менеджер также хранит дескриптор библиотеки и выгружает его после завершения работы движка.
Менеджер платформы также отвечает за предоставление информации о процессоре, например о поддерживаемых SIMD-инструкциях, и за инициализацию определенного режима работы процессов. Других функций формирования запросов системы использовать не могут.4. Интерфейсы
Интерфейсы являются средствами взаимодействия между фреймворком, менеджерами и системами. Фреймворк и менеджеры являются частью движка, поэтому они могут взаимодействовать друг с другом напрямую. Системы к движку не относятся. Более того, все они выполняют разные функции, что приводит к необходимости создания единого метода взаимодействия с ними. Поскольку системы не могут взаимодействовать с менеджерами напрямую, для них необходимо предусмотреть другой способ доступа. При этом не все функции менеджеров должны быть открыты для систем. Некоторые из них доступны только фреймворку.
Интерфейсы определяют набор функций, необходимых для использования стандартного метода доступа. Это избавляет фреймворк от необходимости знать детали реализации конкретных систем, поскольку он может взаимодействовать с ними только посредством определенного набора вызовов.4.1. Интерфейсы субъекта и наблюдателя
Основное назначение интерфейсов субъекта и наблюдателя — регистрация того, каким наблюдателям оправлять уведомления о каких субъектах, а также отправка таких уведомлений. Регистрация и разрыв связи с наблюдателем являются стандартными функциями для всех субъектов, включенными в реализацию их интерфейса.4.2. Интерфейсы менеджеров
Менеджеры, несмотря на то что они являются Singleton-объектами, напрямую доступны только для фреймворка. Другие системы могут получить доступ к менеджерам только через интерфейсы, которые представляют лишь часть их общей функциональности. После инициализации интерфейс передается системе, которая использует его для работы с определенными функциями менеджера.
Не существует единого интерфейса для всех менеджеров. Каждый из них имеет свой отдельный интерфейс.4.3. Интерфейсы системы
Чтобы фреймворк мог получить доступ к компонентам системы, ей необходимы интерфейсы. Без них поддержку каждой новой системы движка пришлось бы реализовывать отдельно.
Каждая система включает в себя четыре компонента, поэтому и интерфейсов должно быть четыре. А именно: система, сцена, объект и задача. Подробное описание см. в разделе 5, «Системы». Интерфейсы — это средства получения доступа к компонентам. Интерфейсы системы позволяют создавать и удалять сцены. Интерфейсы сцены, в свою очередь, позволяют создавать и уничтожать объекты, а также запрашивать информацию об основной задаче системы. Интерфейс задач в основном используется менеджером задач при постановке задач в пул потоков.
Поскольку сцена и объект, как части системы, должны взаимодействовать друг с другом и с универсальной сценой и объектом, к которым они привязаны, их интерфейсы также создают на основе интерфейсов субъекта и наблюдателя.4.4. Интерфейсы изменений
Эти интерфейсы служат для передачи данных между системами. Все системы, выполняющие изменения определенного типа, должны реализовать такой интерфейс. В качестве примера можно привести геометрию. Интерфейс геометрии включает в себя методы определения положения, ориентации и масштаба элемента. Любая система, вносящая изменения в геометрию, должна реализовать такой интерфейс, чтобы для доступа к измененным данным не требовалась информация о других системах.5. Системы
Системы являются частью движка, которая отвечает за реализацию игровой функциональности. Они выполняют все основные задачи, без которых движок не имел бы смысла. Взаимодействие между движком и системами осуществляется при помощи интерфейсов (см. раздел 4.3, «Интерфейсы системы»). Это необходимо, чтобы не перегружать движок информацией о различных типах систем. Благодаря интерфейсам процесс добавления новой системы становится гораздо проще, поскольку в движке не требуется учитывать все детали реализации.5.1. Типы
Системы движка можно условно разделить на несколько заранее определенных категорий, соответствующих стандартным компонентам игры. Например: геометрия, графика, физика (столкновение твердых тел), звук, обработка входных данных, ИИ и анимация.
Системы с нестандартными функциями относятся к отдельной категории. Важно понимать, что любая система, которая изменяет данные конкретной категории, должна знать об интерфейсе этой категории, поскольку движок не предоставляет такую информацию.5.2. Компоненты системы
Для каждой системы необходимо реализовать несколько компонентов. Вот некоторые из них: система, сцена, объект и задача. Все эти компоненты служат для взаимодействия с различными частями движка.
На схеме ниже изображены взаимодействия между различными компонентами.Рисунок 9. Компоненты системы
Подробная схема связей между системами движка приведена в приложении B, «Схема взаимодействия движка и систем».5.2.1. Система
Компонент «система», или просто система, отвечает за инициализацию системных ресурсов, которые практически не будут меняться в процессе работы движка. Например, графическая система анализирует адреса ресурсов для определения места их нахождения и ускорения загрузки при использовании ресурса. Она также задает разрешение экрана.
Система является основной входной точкой для фреймворка. Она предоставляет информацию о себе (например, тип системы), а также методы создания и удаления сцен.5.2.2. Сцена
Компонент «сцена», или системная сцена, отвечает за управление ресурсами, которые относятся к текущей сцене. Универсальная сцена использует системные сцены для расширения функциональности за счет использования их функций. В качестве примера можно привести физическую сцену, которая используется при создании нового игрового мира и при инициализации сцены определяет в нем силы гравитации.
В сценах предусмотрены методы создания и уничтожения объектов, а также компонент «задача» для обработки сцены и метод доступа к нему.5.2.3. Объект
Компонент «объект», или системный объект, принадлежит сцене и обычно связан с тем, что пользователь видит на экране. Универсальный объект использует системный объект для расширения функциональности, предоставляя его свойства как свои собственные.
Примером может послужить геометрическое, графическое и физическое расширение универсального объекта для отображения деревянной балки на экране. Геометрические свойства будут включать в себя положение, ориентацию и масштаб объекта. Для его отображения графическая система будет использовать специальную сетку. А физическая система наделит его свойствами твердого тела для расчета взаимодействий с другими телами и действующих сил гравитации.
В определенных случаях в системном объекте необходимо учитывать изменения универсального объекта или одного из его расширений. Для этой цели можно создать специальную связь, которая позволит отслеживать выполненные изменения.5.2.4. Задача
Компонент «задача», или системная задача, используется для обработки сцены. Задача получает команду на обновление сцены от менеджера задач. Это сигнал для запуска системных функций на объектах сцены.
Выполнение задачи можно разбить на подзадачи, распределяя их также с помощью менеджера задач на еще большее число потоков. Это удобный способ масштабирования движка на несколько процессоров. Такой метод называют декомпозицией данных.
Информация об изменении объектов в процессе обновления задач сцены передается менеджеру состояний. Подробную информацию о менеджере состояний см. в разделе 3.2.2.6. Объединяя все компоненты
Все описанные выше элементы связаны между собой и являются частью одного целого. Работу движка можно условно разделить на несколько этапов, описанных в следующих разделах.6.1. Этап инициализации
Работа движка начинается с инициализации менеджеров и фреймворка.Фреймворк вызывает загрузчик сцены.
Определив, какие системы сцена будет использовать, загрузчик вызывает менеджера платформы для загрузки соответствующих модулей.
Менеджер платформы загружает соответствующие модули и передает их менеджеру интерфейсов, затем вызывает их для создания новой системы.
Модуль возвращает загрузчику указатель на экземпляр системы, которая реализует системный интерфейс.
Менеджер служб регистрирует все службы, которые предоставляет системный модуль.
Рисунок 10. Инициализация менеджеров и систем движка6.2. Этап загрузки сцены
Управление возвращается загрузчику, который загружает сцену.Загрузчик создает универсальную сцену. Чтобы создать экземпляры системных сцен, он вызывает интерфейсы систем, расширяя функциональность универсальной сцены.
Универсальная сцена определяет, какие данные может изменить каждая системная сцена и оповещения о каких изменениях она должна получать.
Сопоставив сцены, выполняющие определенные изменения и желающие получать о них оповещения, универсальная сцена передает эту информацию в менеджер состояний.
Для каждого объекта сцены загрузчик создает универсальный объект, затем определяет, какие системы будут расширять универсальный объект. Соответствие между системными объектами определяется по той же схеме, которая используется для сцен. Оно также передается менеджеру состояний.
С помощью полученных интерфейсов сцен загрузчик создает экземпляры системных объектов и использует их для расширения универсальных объектов.
Планировщик запрашивает у интерфейсов сцен данные об их основных задачах, чтобы в процессе выполнения передать эту информацию менеджеру задач.
Рисунок 11. Инициализация универсальной сцены и объекта6.3. Этап цикла игрыМенеджер платформы используется для обработки сообщений окон и других элементов, необходимых для работы текущей платформы.
Затем управление переходит планировщику, который ждет окончания такта, чтобы продолжить работу.
В конце такта в свободном пошаговом режиме планировщик проверяет, какие задачи были завершены. Все завершенные задачи (то есть готовые к выполнению) передаются менеджеру задач.
Планировщик определяет, какие задачи будут завершены за текущий такт, и ждет их выполнения.
В режиме жесткого пошагового выполнения эти операции повторяются каждый такт. Планировщик передает менеджеру все задачи и ожидает их выполнения.
6.3.1. Выполнение задачи
Управление переходит менеджеру задач.Он формирует очередь из всех полученных задач, затем, по мере появления свободных потоков, начинает их выполнение. (Процесс выполнения задач различается в зависимости от систем. Системы могут работать только с одной задачей или обрабатывать одновременно несколько задач из очереди, реализуя таким образом параллельное выполнение.)
В процессе выполнения задачи могут работать со всей сценой или только с определенными объектами, изменяя их внутренние данные.
Системы должны получать уведомления о любых изменениях общих данных (например, позиции или ориентации). Поэтому при выполнении задачи системная сцена или объект информируют наблюдателя о любых изменениях. В этом случае наблюдатель фактически выполняет роль контроллера изменений, который является частью менеджера состояний.
Контроллер изменений формирует очередь уведомлений об изменениях для последующей обработки. Он игнорирует изменения, которые не касаются данного наблюдателя.
Чтобы воспользоваться определенными службами, задача обращается к менеджеру служб. Менеджер служб также позволяет менять свойства других систем, недоступные для передачи в механизме обмена сообщениями (например, система ввода данных меняет расширение экрана — свойство графической системы).
Задачи также могут обращаться к менеджеру среды для получения переменных среды и для изменения состояния исполнения (приостановка исполнения, переход к следующей сцене и др.).
Рисунок 12. Менеджер задач и задачи6.3.2. Обновление данных
После выполнения всех задач текущего такта основной цикл игры обращается к менеджеру состояний, чтобы запустить этап обновления данных.Менеджер состояний поочередно вызывает каждый из своих контроллеров изменений для рассылки накопленных уведомлений. Контроллер проверяет, каким наблюдателям отправлять уведомления об изменениях для каждого из субъектов.
Затем он вызывает нужного наблюдателя и сообщает ему об изменении (уведомление также включает в себя указатель на интерфейс субъекта). В режиме свободного пошагового выполнения наблюдатель получает измененные данные от контроллера изменений, но в режиме жесткого пошагового выполнения он должен запрашивать их у самого субъекта.
Обычно наблюдателями, заинтересованными в получении уведомлений об изменениях системного объекта, являются другие системные объекты, связанные с одним и тем же универсальным объектом. Это позволяет разделить процесс внесения изменений на несколько задач, которые можно выполнять параллельно. Чтобы упростить процесс синхронизации, можно объединить в одной задаче все связанные расширения универсального объекта.
6.3.3. Проверка выполнения и выход
Итоговый этап цикла игры представляет собой проверку состояния среды выполнения. Существует несколько таких состояний: работа, пауза, следующая сцена и т. п. Если выбрано состояние «работа», будет запущена следующая итерация цикла. Состояние «выход» означает завершение работы цикла, освобождение ресурсов и выход из приложения. Можно реализовать и другие состояния, например «пауза», «следующая сцена» и др.7. Заключение
Основная идея данной статьи изложена в разделе 2, «Состояние параллельного выполнения». Благодаря функциональной декомпозиции и декомпозиции данных можно реализовать не только многопоточность движка, но и его масштабируемость на еще большее количество ядер в будущем. Чтобы исключить издержки на синхронизацию, продолжая поддерживать данные в актуальном состоянии, используйте менеджеры состояния в дополнение к механизму обмена сообщениями.
Шаблон «Наблюдатель» — это функция механизма обмена сообщениями. Важно хорошо понимать принцип ее работы, чтобы выбрать оптимальный способ ее реализации для движка. Фактически это механизм взаимодействия между различными системами, который обеспечивает синхронизацию общих данных.
Важную роль в распределении нагрузок играет управление задачами. В приложении D приведены советы по созданию эффективного менеджера задач для игрового движка.
Как видите, многопоточность игрового движка удается реализовать благодаря четко определенной структуре и механизму обмена сообщениями. С ее помощью можно значительно повысить производительность современных и будущих процессоров.Приложение A. Схема движка
Запуск обработки выполняется из основного цикла игры (см. рис. 4, «Основной цикл игры»).
 Приложение B. Схема взаимодействия движка и систем
 Приложение C. Наблюдатель (шаблон проектирования)
Шаблон «Наблюдатель» подробно описан в книге «Приемы объектно-ориентированного проектирования. Паттерны проектирования», Э. Гамма, Р. Хельм, Р. Джонсон, Дж. Влиссидес («Design Patterns: Elements of Reusable Object-Oriented Software», Gamma E., Helm R., Johnson R., Vlissides J.). На английском языке она впервые была издана в 1995 году издательством Addison-Wesley.
Основная идея данной модели заключается в следующем: если каким-то элементам необходимо получать уведомления об изменениях других элементов, они не обязаны просматривать список всех возможных изменений, пытаясь найти в нем нужные данные. Модель подразумевает наличие субъекта и наблюдателя, которые используются для отправки уведомлений об изменениях. Наблюдатель отслеживает любые изменения субъекта. Контроллер изменений выступает в роли посредника между этими двумя данными компонентами. Следующая схема иллюстрирует данную связь.Рисунок 13. Шаблон «Наблюдатель»
Ниже описан процесс использования данной модели.Контроллер изменений регистрирует наблюдателя и субъекта, уведомления о котором он хочет получать.
Контроллер изменений фактически является наблюдателем. Вместо наблюдателя вместе с субъектом он регистрирует самого себя. Контроллер изменений также хранит свой список наблюдателей и зарегистрированных с ними субъектов.
Субъект вносит наблюдателя (то есть контроллера изменений) в свой список наблюдателей, которые хотят получать уведомления о его изменениях. Иногда дополнительно указывается тип изменений, который определяет, в каких именно изменениях заинтересован наблюдатель. Это позволяет оптимизировать процесс рассылки уведомлений об изменениях.
Меняя данные или состояние, субъект уведомляет наблюдателя посредством механизма обратного вызова и передает информацию об измененных типах.
Контроллер изменений формирует очередь уведомлений об изменениях и ждет сигнала для их распределения по объектам и системам.
Во время распределения контроллер изменений обращается к реальным наблюдателям.
Наблюдатели запрашивают информацию об измененных данных или состоянии у субъекта (или получают их вместе с уведомлениями).
Перед удалением наблюдателя или если ему больше не требуется получать уведомления о субъекте, он удаляет подписку на данный субъект в контроллере изменений. 
Приложение D. Советы по реализации задач
Существует множество разных способов реализовать распределение задач. Однако лучше всего поддерживать количество рабочих потоков равным количеству доступных логических процессоров платформы. Старайтесь не привязывать задачи к определенному потоку. Время выполнения задач различных систем не всегда совпадает. Это может привести к неравномерному распределению нагрузки между рабочими потоками и сказаться на эффективности. Чтобы упростить этот процесс, используйте библиотеки управления задачами, например Threading Building Blocks от Intel.
Существует несколько способов оптимизировать работу менеджера задач, чтобы обеспечить поддержку различных задач ЦП. Вот некоторые из них.Обратная подача. Если порядок основных задач практически не меняется, для каждого следующего фрейма их можно назначать в обратном порядке. Весьма вероятно, что данные последней задачи, выполненной на предыдущем фрейме, все еще находятся в кэше. То есть выполнение задач в обратном порядке исключает необходимость перезаписывать данные в кэше ЦП.
Общий кэш: в некоторых многоядерных процессорах кэш разделен на секции. Таким образом одна пара процессоров может использовать одну часть общего кэша, а другая — другую. Такая модель повышает вероятность того, что при назначении подзадач одной и той же системой необходимые данные уже будут находиться в общем кэше.

    