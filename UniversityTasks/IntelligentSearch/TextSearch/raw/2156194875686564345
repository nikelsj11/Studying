#TITLE:Rust, дисциплинирующий язык программирования

      Здравствуйте, уважаемые читатели!
Жизнь не стоит на месте, и вот в «O'Reilly» задумались об издании первой фундаментальной книги о языке программирования Rust:
Заинтересовавшись этой темой, мы решили вынести на обсуждение перевод обзорной статьи о языке Rust, вышедшей в декабре 2014 года. Статья немного сокращена с учетом того, что некоторые ее отрывки уже устарели, однако автор хорошо рассматривает этот язык в контексте существующих альтернатив, подчеркивает его (безусловные) достоинства и (условные) недостатки. 
Впрочем, чтобы было еще интереснее, оставим в комментарии к этой статье ссылку на другую статью о Rust, опубликованную в одном из наших любимых русскоязычных блогов по программированию. Для начала — заходите под кат.Дисклеймер: Вкус к языкам программирования – дело очень субъективное, как и этот пост. Воспринимайте его со здоровым скептицизмом.
Недавно появилось несколько новых языков программирования. Среди них меня особенно заинтересовал Rust. Ниже я поделюсь моими впечатлениями о Rust и сравню его с несколькими другими языками программирования.Барьер при изучении Rust
Я познакомился с Rust не с первой попытки. При изучении этого языка существует несколько барьеров, в частности:Язык стремительно меняется. В Rust нет «великодушного пожизненного диктатора». Язык развивается благодаря вкладу участников основной команды и сообщества.
Учитывая первый пункт, учебные материалы по Rust очень скудны. Есть руководство, другая официальная документация и сайт Rust by Example – это отличные ресурсы. Однако Rust гораздо сложнее. Зачастую приходится штудировать RFC, блоги и даже комментарии на Github, чтобы отыскать нужную информацию, причем если даже эта информация появилась буквально вчера, все равно в ней нет полной уверенности. Жду хорошей, авторитетной книги по Rust, хотя, готов поспорить, она будет объемистой. 
Система владения и механизм проверки заимствования в Rust может смутить новичков. Для обеспечения безопасности памяти без сборки мусора в Rust задействуется затейливая система заимствования и владения. Зачастую она отпугивает неофитов.
Компилятор Rust очень строгий. Я называю Rust дисциплинирующим языком. Все, что не является для компилятора Rust вполне очевидным, вы должны указывать самостоятельно, причем о некоторых своих намерениях вы и сами поначалу не догадываетесь. Этот барьер обучения, вкупе со всеми остальными, зачастую приводит к тому, что первое впечатление от Rust оказывается обескураживающим. 
Достоинства
У Rust много достоинств. Некоторые из них уникальны. Безопасность памяти без сборки мусора
Пожалуй, это наиважнейшее достижение Rust. В низкоуровневых языках программирования, допускающих непосредственную манипуляцию с памятью, такие ошибки, как использование освобожденной памяти (use-after-free) или утечки памяти во время исполнения довольно накладны. В современном языке C++ возможности борьбы с такими вещами улучшились, однако они предполагают строгую техническую дисциплину (читай: программисты продолжают выполнять небезопасные операции). Соответственно, на мой взгляд, в целом С++ не может принципиально и надежно решить эту проблему. 
Действительно, Rust-программисты могут писать небезопасный код в блоке unsafe, но (1) это делается осознанно и (2) блоки unsafe могут составлять лишь очень малую долю всей базы кода, при этом они строго контролируются. 
Сборщик мусора — самый обычный инструмент, обеспечивающий безопасность памяти. Если вы ладите с GC, то вариантов у вас не мало. Однако система владения, применяемая в Rust, обеспечивает не только безопасность памяти, но и безопасность данных и ресурсов (см. ниже)RAII и ресурсыRAII (получение ресурса есть инициализация) — странный термин, но хорошо передает заложенную в нем идею. В Википедии читаем, что RAII работает с объектами, выделяемыми в стеке. Система владения Rust позволяет применять этот принцип и с объектами, выделяемыми в куче. Благодаря этому автоматическое высвобождение ресурсов – например, памяти, файлов, сокетов — становится хорошо предсказуемым и гарантированным во время компиляции. 
В динамических языках вроде Python или Ruby есть подобные возможности, но они не сравнятся по мощности с Rust IMO.Конкурентность без гонок данных
Rust обеспечивает безопасность данных при конкурентном программировании — то есть, гарантирует, что в любой конкретный момент времени обратиться к данным могут лишь множество считывателей или один «записыватель».Алгебраический тип данных
Кроме обычных типов (кортежи и структуры) в Rust также предоставляются перечислимые типы (здесь они называются «типы-суммы» или «вариантные типы») и сравнение с шаблоном. Удивительно, что у языка для системного программирования такая развитая система типов. Композиция приоритетнее наследования
В Rust композиция типов явно предпочитается наследованию. Я отношусь к тому лагерю, где этот факт считается выигрышным. При поддержке обобщенных типов в Rust ключевая роль отводится типажам.Недостатки (условные)Все должно быть предельно четко
Rust — дисциплинирующий язык. Компилятору необходимо все сообщать предельно четко, либо он будет ругаться, пока не останется никаких невыясненных моментов. Как правило, это идет на пользу качеству кода, но может быть избыточно, если речь идет о быстром прототипировании или одноразовых задачах.
В итоге: приходится писать на Rust более качественный и четкий код. Как только это усвоишь, шероховатости могут более или менее сойти на нет. Сборка мусора вторична
В Rust есть простейший сборщик мусора: Rc, подсчет ссылок и Arc, атомарный подсчет ссылок без циклического обнаружения. Однако эти возможности не действуют в языке по умолчанию, и вам придется чаще использовать стандартные механизмы управления памятью в Rust (стек, &amp; и Box). Если проблемы с памятью в вашем приложении несущественны, то вам придется потерпеть Rust-овскую модель безопасности памяти, где не применяется сборщик мусора.Выразительность — не самоцель
Язык Rust не заморачивается о выразительности и красоте кода. В этом отношении он определенно неплох, но не так чудесен, как, возможно, вы бы хотели. Сравнительно высокий входной барьер
В принципе, Rust — не из тех языков, которые можно быстро освоить и уже через несколько недель писать профессиональный код. Пожалуй, Rust компактнее С++, но определенно больше, чем многие языки программирования. По сравнению с другими языками его не назовешь слишком доступным. Это может оказаться проблемой, если ваш приоритет — скорость освоения языка. Rust и другие языкиДинамические языки
Динамические (сценарные) языки находятся на противоположном от Rust конце спектра языков программирования. По сравнению с Rust, писать код на динамических языках обычно быстрее и проще. Думаю, динамические языки выигрывают у Rust в таких ситуациях:Быстрое прототипирование или одноразовые задачи
Код не для продакшена, либо такой, где ошибка во время исполнения — небольшая проблема
Собственный (индивидуальный) проект
Полуавтоматическая работа (напр. парсинг/анализ логов, пакетная обработка текста)
Т.д.

В таких случаях не стоит стараться все сделать идеально. Напротив, Rust, на мой взгляд, лучше подойдет для:Работы в средней или крупной команде
Кода, ориентированного на долгосрочное использование в продакшене
Кода, который будет использоваться долго, предполагает регулярную поддержку и/или рефакторинг 
Код, для обеспечения безопасности которого вы бы написали много модульных тестов

В общем, когда критично качество кода. Динамические языки помогают писать код быстрее на начальном этапе, однако впоследствии работа тормозится: приходится писать больше тестов, нарушается линия разработки или даже возникают перебои при работе в продакшене. Компилятор Rust вынуждает вас делать многие вещи правильно уже во время компиляции, когда не столь накладно выявлять и фиксить баги. Go
Сравнение двух этих языков – отличный повод поспорить, но, поскольку я некоторое время изучал Go, все-таки поделюсь здесь моими субъективными впечатлениями о нем. По сравнению с Rust, вот что мне нравится в Go:легковесность – язык маленький (и простой, при этом очень мощный)
утилита gofmt – значительно снижает умственную нагрузку при программировании 
goroutine/channel
Мгновенная компиляция

Почему я завязал с Go:Он слишком минималистичен. Система типов и сам язык не слишком расширяемы 
Программирование на Go кажется мне немного сухим. Напоминает дни, когда я программировал на Java: хорошо подходит для корпоративной разработки, механистично и… не так интересно (напоминаю: о вкусах не спорят) 
Популярность Go сохраняется благодаря поддержке Google, но это вызывает у меня некоторый скепсис. Когда интересы сообщества и компании не совпадают, первыми могут пожертвовать. Разумеется, любая компания преследует прежде всего собственные интересы. В этом нет ничего плохого. Это просто… немного раздражает. (Многие языки и фреймворки, продвигаемые корпорациями, сталкиваются с подобной проблемой. Mozilla хотя бы не зависит от биржевых котировок).
NimNim (раньше назывался Nimrod) — очень интересный язык. Он компилируется в C, поэтому производительность у него весьма хорошая. Внешне он напоминает Python — язык, программировать на котором мне всегда нравилось. Это язык со сборкой мусора, однако в нем предоставляется мягкая поддержка в реальном времени, и само поведение сборщика мусора более предсказуемое. В нем интересная система эффектов. В принципе, этот язык мне очень нравится. 
Самая большая проблема в его случае — незрелость экосистемы. Сам язык хорошо сработан и относительно стабилен, но в настоящее время этого далеко не достаточно, чтобы язык программирования преуспел. Документация, стандартные библиотеки, репозитории пакетов, поддерживающие фреймворки, участие сообщества и сторонних разработчиков… довести все это до готовности к продакшену нелегко.
Без специалистов, которые бы занимались доработкой языка на фултайме, этот последний этап может быть очень изнурительным. Среди новых языков программирования Nim пока не может похвастаться серьезной поддержкой.
При этом, я желаю ему успеха и по-прежнему слежу за ним.Прочие
Есть и другие языки вроде Julia и D. Julia — динамический язык с хорошей производительностью и гладкими вызовами в стиле C. (Если вы любите динамические языки и REPL — обратите внимание). Julia привлек всеобщее внимание, благодаря своим числовым и научным полям. Хотя он и может стать языком общего назначения, мне кажется, что на развитие этого языка значительно влияет сообщество его зачинателей. 
D, как минимум, изначально, представлял собой попытку создать «C++, только лучше». Его версия 1.0 вышла в 2007 году, поэтому данный язык не такой уж и новый. Это хороший язык, но по объективным причинам он до сих пор не прижился: дело и в расколе на Phobos/Tango на раннем этапе, и в обеспечении безопасности памяти в первую очередь через сборку мусора, и в изначальном позиционировании в качестве замены для C++.Почему я считаю, что шансы у Rust довольно высоки
В наше время появляется так много новых языков программирования. Чем же, на мой взгляд, среди них выделяется Rust? Приведу следующие доводы:Настоящий язык для системного программирования
Встраиваемость — нелегкая задача. Пожалуй, она решается буквально на нескольких языках, а то и всего на двух: C и C++. (Возможно, именно поэтому Skylight выбрала Rust для разработки расширения для Ruby, хотя это и было крайне рискованно.) Примечательно, насколько хорошо Rust удалось избавиться от издержек времени исполнения. Это открывает перед Rust уникальные перспективы.Без Null
Null-объект/указатель (так называемая "ошибка на миллиард долларов") — распространенный источник ошибок времени исполнения. Существует лишь несколько языков программирования, в которых отсутствует null, в основном это функциональные языки. Дело в том, что для избавления от null требуется очень продвинутая система типов. Как правило, чтобы справиться с этим на синтаксическом уровне языка, требуется алгебраический тип данных и сравнение с шаблоном. Низкоуровневый язык с продвинутыми высокоуровневыми конструкциями
Будучи вплоть до ядра «языком на голом металле» (как минимум, теоретически), Rust также предлагает множество относительно высокоуровневых возможностей, в том числе, алгебраический тип данных, сравнение с шаблоном, типаж, выведение типов и т.д. Сильное сообщество и практическая востребованность
Сообщество Rust очень дружелюбное и активное. (Разумеется, это субъективное впечатление). Кроме того, Rust использовался в некоторых серьезных практических проектах — речь, в частности, о компиляторе Rust, Servo, Skylight и т.д. еще на этапе разработки языка. До сих пор — без крупных ошибок
Временами разработка языка или фреймворка, ведущаяся в рамках компании, может случайно зайти в тупик. К счастью, основная команда Rust пока отлично справляется со своими задачами. Так держать, Rust!Rust для веб-разработки
Если Rust – язык для системного программирования, подойдет ли он для веб-разработки? Я ищу ответ и на этот вопрос.Библиотеки и фреймворки
В первую очередь, для этого должны быть готовы некоторые HTTP-библиотеки. (Об этом рассказано на сайте «Are we web yet»). Первая библиотека rust-http уже устарела; ее потенциальная наследница Teepee практически в анабиозе. К счастью, Hyper кажется хорошей кандидатурой. Она уже принята в Servo, симбиотическом проекте Rust, я расцениваю это как благословление на роль HTTP-библиотеки для Rust.
Стандартная библиотека Rust пока не поддерживает асинхронный ввод/вывод. Для этой цели можно использовать внешнюю библиотеку mio, обеспечивающую неблокирующий сокетный ввод/вывод. Поддержка зеленых потоков была упразднена в рамках упрощения I/O.
Активно разрабатывается несколько веб-фреймворков для Rust, в их числе — Iron и nickel.rs. Может потребоваться время, прежде чем ситуация с ними уляжется.Rust – язык для веба?
Когда-нибудь библиотеки и фреймворки будут готовы. Вопрос в том, подходит ли Rust как таковой для веб-разработки? Не слишком ли сложны низкоуровневые возможности Rust, связанные с управлением памятью и обеспечением безопасности?
Думаю, в конечном итоге все зависит от того, чего вы ожидаете от проекта. Выше, сравнивая Rust с динамическими языками в краткосрочных проектах, я упоминал, что в таких случаях сложность Rust может быть неоправданной. Но если вы рассчитываете, что продукт просуществует достаточно долго – скажем, полгода и более — то Rust может быть неплохим вариантом. Годится ли Rust для веб-стартапов?
Что насчет стартапов? На них требуется быстрое прототипирование и циклы разработки. Это более неоднозначный вопрос, но я остаюсь при своем мнении: если вы рассчитываете на долгосрочный проект, то важно правильно подобрать язык программирования, и Rust заслуживает особого внимания. С точки зрения бизнеса язык, обеспечивающий быстрое прототипирование, дает существенные преимущества, а рефакторинг и устранение узких мест всегда можно оставить на потом. Инженерная реальность такова, что стоимость работ по рефакторингу обычно выше, чем кажется, и даже если вы перетряхнете массу элементов вашей системы, то код, написанный когда-то давно, все равно сохранится в каком-нибудь уголке. На долгие годы. Попробуйте Rust!
Все-таки, рекомендую познакомиться с Rust. Пока с ним возможны шероховатости, но я уверен, что вскоре они исчезнут.
        	
		

	

		Востребованность книги о Rust

		
					


				
					Купил бы серьезную книгу об этом языке даже сейчас
				
			
					


				
					Слишком экзотическая вещь, поддерживаю мнение из первого и второго комментария
				
			
					


				
					Подожду более стабильного релиза
				
			Проголосовало 338 человек. Воздержалось 132 человека.
	

    Только зарегистрированные пользователи могут участвовать в опросе. Войдите, пожалуйста.
	

      
    