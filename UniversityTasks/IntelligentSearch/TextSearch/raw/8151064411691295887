#TITLE:Как оптимизировать работу интернет-магазина. Часть 1. Автоматический прозвон входящих лидов

      Через неделю после выхода предыдущей статьи, где я рассказывал о сборке бота для Telegram, ко мне за консультацией обратился интернет-магазин наручных часов, который к тому моменту уже построил некоторые процессы для своих нужд. При росте бизнеса они столкнулись с проблемой обработки большого количества входящих заявок, а от быстрой реакции на заявку зависит, купит человек продукт или нет. 
Здесь я опишу их кейс оптимизации процессов интернет-магазина с помощью Corezoid.com и дам в открытый доступ ссылку на шаблон процесса, описанного ниже.Что необходимо сделать:
1) Добавить лид в CRM (в данном случае это Bitrix24) c заполнением всех необходимых дополнительных полей.
2) Уведомить продавцов о пришедшем лиде или ошибке.
3) Уведомить клиента об успешно принятом заказе, а так же рассказать о дополнительной акции (попытаться подогреть клиента, повысить средний чек).На входе имеем: 
1) Имя и телефон клиента, которого заинтересовал наш товар.
2) Определенный по ip город клиента.
3) Таймзону клиента.
4) Идентификатор партнера (реф-ссылка в cookies), от которого пришла заявка.
Решением стало связка API нескольких сервисов через Corezoid.com, а именно: Bitrix24 (СRM-система) + VoxImplant (сервис для реализации обратного вызова) + Telegram (messenger).
Чтобы отправить лид на обработку в Corezoid необходимо сделать API-запрос с php-скрипта, который получает данные с web-формы на сайте. На их примере это выглядит так:$data = (object) array('server'=&gt;$_SERVER,'cookies'=&gt;$_COOKIE,'post'=&gt;$_POST );
$full = (object) array('ops'=&gt; array( (object) array( 'ref'=&gt;$ip,'type'=&gt;'create','obj'=&gt;'task','conv_id'=&gt;'31754','data'=&gt; $data)) );

$cmd = ( json_encode( $full ) );
$str = "curl 'https://www.corezoid.com/api/1/json/public/31754/e4203ff8f55f17595a46549d35dbd00d51d0879d' -H 'Accept: application/json, text/javascript, */*; q=0.01' --data '".$cmd."' --compressed";

$res = shell_exec($str);

Объект $data формируется из данных, которые необходимо передать на обработку в Corezoid.
Объект $ops включает в себя параметр ref (referense) – уникальный id, под которым заявка зафиксируется в Corezoid. Если в данный момент уже есть заявка в процессе работы с таким же ref, то вторая добавлена не будет. В этом примере они используют в качестве ref ip-адрес клиента.
Параметр conv_id отвечает за формирование задачи в определенном процессе (ID Process).
URL, на который будем отправлять данные и conv_id процесса, берем из свойства в админке:Обработка заявки
Первым делом заявка попадает в стартовый узел. Он отличается от всех зеленым цветом. Можно просмотреть эту заявку и увидеть данные, которые поступили на вход. 
Так как магазин активно использует схему партнерских продаж, первым делом необходимо определить, от какого партнера пришел заказ. 
Через API Bitrix24 получаем ID и данные этого партнера.
Для авторизации в API в значение параметра “auth” подставляем конструкцию, которая позволяет динамически получать значение «access_token» из процесса его генерации и обновления. Подробное описание этого процесса в документации на Corezoid.com
В этом примере, данные по метке партнера хранятся в объекте «cookies» в параметре «utm_source», которые компания отслеживает после перехода по партнерской ссылке. Передаем значение этого параметра в API.
Следующий шаг за логикой CODE, в которой магазин обрабатывает телефон. Обработка заключается в автозамене первой цифры 8 на 7, и в случае если клиент ввел только 10 цифр и первая начинается на 9, то добавляют 7 в начало, для того чтобы телефон корректно обрабатывался скриптом дозвона.
Следующим шагом они отправляют заявку в отдельный RPC-процесс «Create new lead [RPC]». Он создает лид в CRM и возвращает ID лида. В документации Corezoid имеется подробное описание данного процесса. 
В случае успешного создания лида id вернется в переменную lead_id. 
Следующим шагом заявка копируется в процесс, который будет дозваниваться до клиента. После копирования сразу же перейдет на следующий шаг, не дожидаясь возврата каких-либо значений из процесса VoxImplant Robot Call. Это основное отличие от RPC-запроса, когда ожидается возврат данных из другого процесса.
Логика дозвона первым делом добавляет переменную с длиной телефона через логику CODE. Если телефон длиннее чем 11 цифр, то он отправляется в финальный узел, так как телефон слишком длинный.
Следующий блок получает текущее время по МСК в переменную timenow.
Это необходимо для того, чтобы, если лид пришел ночью или рано утром, магазин не стал беспокоить клиента ночным звонком, а просто отправили SMS об удачно принятом заказе и сообщении, что перезвонят в рабочее время.
После логики CODE в этом же блоке проверяется время суток и факт отправки SMS клиенту. Если сообщение не было отправлено и время не рабочее, то заявка переходит в блок «Send Night SMS». Тут магазин отправляет SMS клиенту через логику API и получают ответ в переменную description. Затем уходят «спать» в таймаут на 2 часа. 
Заявка, висящая в тайм-ауте, выглядит так:
Если же время рабочее, то нужно позвонить клиенту и сообщить об успешно принятом заказе, ну и рассказать о дополнительной акции.
Эта задача была реализована через логику API, которая запускает сценарий на сервисе VoxImplant.
VoxImplant осуществляет звонок клиенту и проигрывает ему подготовленную запись об успешно принятом заказе. Дополнительно в код встроена функция определения автоответчика.{код сценария}
Далее заявка уходит в логику Callback в Corezoid, которая ожидает ответ от VoxImplant c результатами звонка. Если мы не дождались ответа, что-то пошло не так, и заявка «падает» в ручную обработку. Если всё ок, и VoxImplant прислал результаты, то входим в процесс распределения результатов.
Если номер неверный, то заявка уходит в финальный узел, звонить и отправлять SMS на этот номер нет смысла. Если же клиент не взял трубку или сейчас его телефон выключен, то наша заявка переходит в статус «Недозвон» и берет тайм-аут в полчаса.
Если же до клиента успешно дозвонились, то дополнительно оповещаем через SMS, что его заказ успешно принят, и закрываем заявку. При определении VoxImplant’ом автоответчика магазин также отправляет SMS клиенту, но дальше не звонят, так как неизвестно, когда клиент возьмет трубку, а магазин будет тратить деньги на каждый звонок. Дополнительно в логику можно встроить ограничение на количество дозвонов, а также обновление лида в CRM со статусом звонка.
В процессе также предусмотрено уведомление в Telegram продавцу, если в главном процессе при получении списка партнеров будет невалидный token и нужно обработать заявку в ручную. И уведомление о успешно добавленном лиде. А в процессе для дашборда, с помощью логики IF, заявки распределяются по узлам согласно критериям, которые определяют партнера или сайт и общую сумму заказов от каждого партнера. В следующих статьях я буду описывать другие кейсы использования Corezoid в интернет-магазине и делиться шаблонами:организация партнерской программы (Bitrix24 + Corezoid + Google Sheets);
автоматизация работы курьерской службы (MoySklad + Corezoid + Telegram);
Проверка статуса накладной (Cdek + Corezoid + Telegram);
Бот – контролер исполнения бизнес-процессов (Telegram + Corezoid + Bitrix).

О том, что наиболее интересно, пишите в комментариях.
Шаблон, описанный в статье, доступен по ссылке. А собственные кейсы объединения разных сервисов в единую экосистему Вы можете реализовать на Corezoid.com.
Есть вопросы? 
Можете связаться со мной в Telegram или по e-mail.

      
      
    