#TITLE:Повышаем эффективность массива

      Данная статья подготовлена Николаем Ведяшкиным, экспертом Сервисного центра компании «Инфосистемы Джет».
Представим себе ситуацию: мы добавили на сервер базы данных новый instance БД или новое задание резервного копирования (РК), подключили дополнительный сервер к дисковому массиву и во всех этих случаях обнаружили снижение его производительности. Дальше можно пойти разными путями. 
Например, добавить сервер БД и перенести на него экземпляр базы данных, добавить резервных накопителей для ускорения РК, сделать апгрейд процессоров и т.д. Однако стоит помнить, что простое наращивание аппаратных мощностей наименее выгодно с точки зрения материальных и временных затрат. Намного эффективнее решать такие проблемы на уровне логики работы ИТ-решений. Причины пробуксовки
Проблемы с производительностью массива часто связаны с тем, что при изначальном конфигурировании не учитываются его архитектура, принципы функционирования и существующие ограничения. Например, ахиллесова пята массивов старого поколения – относительно невысокоая пропускная способность внутренних шин – около 200 Мб/сек. Не так давно один из заказчиков попросил нас проанализировать работу его дискового массива и дать рекомендации по оптимизации. По факту массив был не загружен, при этом его скорость периодически оставляла желать лучшего. Анализ выявил неправильную конфигурацию: в целом в течение суток внутренние диски были загружены примерно одинаково, но пики нагрузки распределялись по ним неравномерно. В итоге одна из внутренних шин перегружалась. То есть массив «буксовал» из-за превышения максимально допустимого порога у одной компоненты. Наша рекомендация – переразбить его для равномерной загрузки внутренних шин – помогла увеличить производительность на 30%. 
Ошибка может закрасться и при подключении серверов к СХД. Пример – неправильная конфигурация дисковой емкости, которая представляется хостам. Дело в том, что некоторые из современных массивов имеют ограничения по такому параметру, как очередь команд (Queue Depth, QD). Здесь стоит немного углубиться в историю. В стандарте SCSI-I SCSI-драйвер сервера должен был дождаться выполнения одной команды и только после этого отправлять следующую. Со стандарта SCSI-II и выше SCSI-драйвер может отправить SCSI-диску одновременно несколько команд (QD). Максимальное количество параллельно обслуживаемых SCSI-команд – одна из важнейших характеристик диска. Параметр IOPS (Input Output Operation per Second) показывает, сколько запросов (SCSI-команд) в секунду способен выполнить SCSI LUN. Получается, что QD и IOPS могут вступать в непримиримое противоречие друг с другом. 
Вполне реальна ситуация, при которой характеристики ввода-вывода на стороне сервера неприемлемы, время отклика на запросы очень большое, а массив не нагружен. Причина кроется в – неправильной настройке очереди команд (выше допустимого) – команды зависают в буфере массива, пока не подойдёт их очередь на исполнение. На сервере же регистрируются большие service time. 
Если же QD существенно ниже оптимального значения, производительность также будет хромать. При замечательном времени отклика и не загруженном массиве количество обрабатываемых им запросов будет очень маленьким. Виной всему – длительное ожидание в очереди перед отправкой запросов к СХД. Ловим IOPS за хвост 
Что предпринять, если время отклика зашкаливает, а массив не загружен? Или если просто хочется «выжать» из массива еще чуть-чуть?
Можно:заглянуть в настройки Queue Depth на сервере и сравнить максимально допустимую очередь команд с LUN массива. Скорректировать настройки;
посмотреть на статистику с массива. Возможно, на нем копится очередь команд к LUN;
разбить один LUN на несколько и соединить на хосте в stripe или хотя бы в конкатенацию в зависимости от конфигурации. Конкатенация полезна в том случае, если нагрузка распределится по всем LUN. 
выбрать размер stripe unit size на массиве и хосте так, чтобы типичная операция со стороны приложения нагружала как можно меньше физических дисков в массиве. 
Рис. 1. Stripe Unit Size 
Пример из нашего опыта: связка «сервер–массив» у заказчика не показывала заявленный уровень производительности. В результате анализа выяснилось, что серверу был дан очень большой (на несколько терабайт) LUN – работа приложений была неудовлетворительной, а сам LUN был перегружен по очереди команд. Мы рекомендовали разбить этот LUN на несколько и разнести виды нагрузки на разные тома. На сервере «крутились» 4 instance баз данных, в итоге один из них начал работать в 6 раз быстрее, другой – в 2 раза. Больше не значит лучше
ИТ-специалисты компаний-заказчиков не всегда понимают, какой тип RAID лучше подходит для того или иного профиля нагрузки со стороны приложений. Всем известно, что RAID 10 надежен, устойчив к потере нескольких дисков и показывает хорошую скорость на случайных операциях. Не удивительно, что чаще всего выбирают именно этот, весьма дорогостоящий вариант. Однако если профиль нагрузки приложения подразумевает мало операций случайной записи и много операций чтения или последовательной записи, оптимальнее использовать RAID 5. На том же количестве дисков он может работать в 1,5, а то и в 2 раза быстрее. Одна компания обратилась к нам с просьбой улучшить характеристики дискового ввода/ввода для одного из ее приложений. Приложение создавало много операций чтения и незначительное количество операций записи. На массиве был сконфигурирован RAID 10, а из статистики было видно, что практически половина дисков в RAID-группе простаивает. С переходом на RAID 5 из точно такого же количества физических дисков работа приложения улучшить более чем в 1,5 раза. 
Мы будем рады вашим конструктивным комментариям.
Проблемы производительности затрагивают практически каждую компанию, эксплуатирующую вычислительный комплекс. Приведённые здесь примеры не единственные. Множества проблем, связанных с неудовлетворительной работой массивов, можно избежать, если при конфигурировании оборудования учитывать его архитектуру и профиль нагрузки приложений. В то же время улучшение работы вычислительного комплекса не должно замыкаться на каком-то одном его компоненте – сервере, массиве, ПО или сети передачи данных. Наилучших результатов можно достичь после проведения анализа всего комплекса в целом и изменения конфигурации не только массива, но и сервера и приложений.

      
      
    