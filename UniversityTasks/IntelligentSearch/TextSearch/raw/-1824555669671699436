#TITLE:Углубление в Scheme

      Если единственный инструмент, которым вы располагаете, это молоток, то множество различных предметов покажутся вам гвоздями.
Марк ТвенЧасть 1 Введение в SchemeЧасть 2 Углубление в SchemeЧасть 3 Практика IronSchemeЗнакомимся ближе
Настало время изучить основные конструкции языка Scheme. Самый лучший способ научиться использовать новый язык это начать на нем писать. Начнем постепенное погружение с разбора самых базовых элементов языка. 
Предлагаю запустить интерпретатор IronScheme в REPL режиме и вводить приведенные ниже команды.
Однострочный комментарий начинается с точки с запятой и действует до конца строки:; эта строка будет игнорирована интерпретатором

Программа на Scheme состоит из списков заключенных в круглые скобки и разделенных пробелом(s-выражение). Вызов функции записывается как (f x y z …), где f имя функции, а x, y, z, … операнды.(+ 2 2)  ;  =&gt; 4

Здесь мы выполнили операцию сложения двух чисел.
Выражения могут быть вложенными:(+ 2 (+ 1 1))  ; =&gt; 4

Таким образом, выражения могут состоять из атомов или других выражений. В приведенном выше примере числа «1» и «2» атомы, а «(+ 2 (+ 1 1))» и «(+ 1 1)» выражения.Примитивы
Числа:9999999999999999999999 ; integers
#b111                  ; binary =&gt; 7
#o111                  ; octal =&gt; 73
#x111                  ; hexadecimal =&gt; 273
3.14                   ; reals
6.02e+23
1/2                    ; rationals
1+2i                   ; complex numbers

Чтобы создать список каких-либо значений, например из тех же примитивов, следует использовать функцию list, аргументы которой соберутся в список. Можно поступить другим способом, подавить вычисление. Подавление достигается функцией quote или ее сахарным аналогом одиночной кавычкой перед списком “ ’ ”. Важно помнить, что list не подавляет вычисления.(list 1 2 3 4 5 (+ 1 2 3))    ; =&gt; (1 2 3 4 5 6)
(quote (1 2 3 4 5 (+ 1 2 3))) ; =&gt; (1 2 3 4 5 (+ 1 2 3))
'(1 2 3 4 5 (+ 1 2 3))        ; =&gt; (1 2 3 4 5 (+ 1 2 3))
Некоторые арифметические операции(+ 1 1)              ; =&gt; 2
(- 8 1)              ; =&gt; 7
(* 10 2)             ; =&gt; 20
(expt 2 3)           ; =&gt; 8
(quotient 5 2)       ; =&gt; 2
(remainder 5 2)      ; =&gt; 1
(/ 35 5)             ; =&gt; 7
(/ 1 3)              ; =&gt; 1/3
(exact-&gt;inexact 1/3) ; =&gt; 0.3333333333333333
(+ 1+2i  2-3i)       ; =&gt; 3-1i
Булева алгебра
Для обозначения истины имеется примитив “#t”, ложь обозначается как “#f”, кроме того все другие значения отличные от “#f” трактуются как истина:(not #t)   ; =&gt; #f
(and 0 #f) ; =&gt; #f
(or #f 0)  ; =&gt; 0
Символы, строки
Согласно стандарту RnRs, символы можно представить в коде двумя способами, символом который обозначает самого себя или кодом символа:#\A     ; =&gt; #\A
#\x03BB ; =&gt; #\λ

Строки являются массивами символов фиксированной длинны и заключаются в двойные кавычки:"Hello, world!"

Кавычки внутри строки можно экранировать обратным слешем:"Benjamin \"Bugsy\" Siegel" 

Для печати строки в стандартный вывод можно использовать функцию «display» принимающую в качестве аргумента строку:(display "Some string")

Строки можно объединять:(string-append "Hello " "world!") ; =&gt; "Hello world!"

Получить доступ к символу строки по индексу можно так:(string-ref "Apple" 0) ; =&gt; #\A

Для форматирования строк удобно использовать функцию форматирования:(format  "~a can be ~a" "strings" "formatted") ; =&gt; "strings can be formatted"

Чтобы результат форматирования не был потерян можно присвоить строку переменной:(define str (format "~a can be ~a" "strings" "formatted"))
Переменные
Вы можете объявлять переменные, используя функцию «define», в которой первый аргумент имя функции, второй не обязательный аргумент значение которым переменная будет инициализирована. Имя переменной может содержать любые символы за исключением: ()[]{}”,’`;#/\
Например:(define some-var 5)
some-var ; =&gt; 5

Переменные в Lisp без строгой типизации и могут указывать на атомы или функции.
Операция «set!» сохраняет значение в переменной, по сути, является аналогом оператора присвоения «=» из других языков. Не забываем сначала объявить переменную операцией «define»:(define my-name "unknown")
my-name ; =&gt; "unknown"

(set! my-name "NalaGinrut")
my-name ; =&gt; " NalaGinrut "

Попытка доступа к прежде необъявленной переменной вызовет исключение.
Удобно объявлять сразу группу локальных переменных при помощи конструкции (let …).(let 
  (
    (a "My") 
    (b "name") 
    (c "is") 
    (d "Bob")
  ) 
  (set! d "Sara")
  (format "~a ~a ~a ~a" a b c d)
)

; =&gt; My name is Sara
Функции
Для создания функции используется конструкция (lambda (a b c) body), где a, b, c аргументы, body последовательность команд.(lambda () "Hello World")
(lambda (x) (+ x x)) 

Созданная выше функция не имеет имени, поэтому обратиться к ней нет возможности. Чтобы получить доступ к созданной функции ее можно присвоить переменной(define hello-world (lambda () "Hello World"))
(hello-world) ; =&gt; "Hello World"

Или так:(define hello-world)
(set! Hello-world (lambda () "Hello World"))
(hello-world) ; =&gt; "Hello World"

Обычно используется более удобная конструкция (define (function-name arg1 arg2) body)(define (mul a b) (* a b))
(mul 2 3); =&gt; 6

Функция всегда возвращает последнее значение.(define (last-string) “one” “two” “three”)
(last-string) ; =&gt; “three”
Управление потоком
Для ветвления в Scheme существуют, различные конструкции наиболее привычной, но не всегда самой удобной может показаться конструкция типа if-then-else(if #t               ; условие
  "this is true"     ; если истина
  "this is false")   ;  ели ложь
; =&gt; "this is true"

Если в ветви необходимо выполнить несколько команд подряд, то их следует заключить в блок «begin»(if (&lt; 1 3) 
  (begin
    (display “one line”)
    (newline)
    (display “two line”)
    (- 1 3)
  )
)

Когда нужно проверить несколько условий удобна конструкция «cond»(cond 
  ((&gt; 2 2) "wrong!")
  ((&lt; 2 2) "wrong again!")
  ((= 2 2) "ok")
  (else "wrong also")
)

Если код необходимо выполнить только в случае истины прекрасно подходит «when»(when (&lt; 1 3) “true”)

Организовать цикл можно двумя способами, рекурсией(define (lp i)
  (when (&lt; i 10)
    (display (format  "i=~a\n" i))
    (lp (+ 1 i))
  )
)
(lp 5) ; =&gt; i=5, i=6, ...

Или при помощи именованного «let»(let loop ((i 0))                 ; definition
  (when (&lt; i 10)                  ; condition
    (display (format "i=~a\n" i)) ; body
    (loop (+ 1 i))                ; next iteration
  )
) ; =&gt; i=0, i=1, ...
Макросы
Макросы Scheme довольно мощный инструмент, который позволяет расширять синтаксис языка, создавая новые конструкции. Однако не следует слишком увлекаться и применять макросы только там, где это действительно необходимо. Определение макроса начинается с команды «define-syntax»(define-syntax macro
  (syntax-rules (&lt;keywords&gt;)
    ((&lt;pattern&gt;) &lt;template&gt;)
    ...
    ((&lt;pattern&gt;) &lt;template&gt;)
  )
)

&lt;keywords&gt; — Ключевые слова, которые можно будет использовать в описании шаблона. Например, можно написать макрос для конструкции «(forech (item in items) …)», в данном случае ключевым словом будет «in», которое обязательно должно присутствовать.
&lt;pattern&gt; — Шаблон, описывающий, что на входе у макроса.
&lt;template&gt; — Шаблон, описывающий, во что должен быть трансформирован В макросе многоточие «…» означает, что тело может содержать одну или более форм.
Рассмотрим применение макросов для создания циклов while и for.(define-syntax while
  (syntax-rules ()
    ((while condition body ...)
      (let loop ()
        (when condition
          body ...
          (loop)
        )
      )
    )
  )
)

проверим созданный макрос(define iter 0)
(while (&lt; iter 10) (set! iter (+ iter 1)) (displayln iter )) ; =&gt; 1 2 3 …

Определим макрос для цикла for:(define-syntax for
  (syntax-rules ()
    ((for (iterator from to) body ...)
      (let loop((iterator from))
        (when (&lt; iterator to)
          body ...
          (loop (+ 1 iterator))
        )
      )
    )
  )
)

Проверим:(for (i 0 15) (displayln i)) ; =&gt; 1 2 3 ...
Исключения
В жизни не очень редко появляется необходимость использовать нестабильный код, который во время исполненя может вызвать исключение. В Lisp и в частности Scheme развитая система обработки исключений, ниже приводится простой пример, как можно обрабатывать исключения не опасаясь, что программа потерпит крах.(guard
  (cond ; переменная c информацией об исключении
    (display (condition-message cond)) ; тело обработчика
  )
  (/ 1 0) ; код вызывающий исключение
)

Мы изучили некоторые из основ языка Scheme описанные стандартом. Конечно, в данной статье приведены далеко не все возможности языка иначе статья получилась бы слишком объемной, по сути это был бы перевод стандарта. Однако, то что мы узнали, вполне достаточно для разработки практически полезных приложений на Scheme.

      
      
    