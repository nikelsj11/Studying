##Отчет по лабораторной работе №3
&nbsp; | &nbsp;
 --------------------- | ---------------------------------- 
**Предмет**            | *Методы интеллектуального поиска*   
**Выполнил**           | *Красюк Никита*                    
**Группа**             | *НК-401*                           
**Студенческий билет** | *103111130*  
                      
---------------------------------------------------------------------
### Постановка задачи
Реализовать программу индексации и поиска информации.
Программа получает на вход путь к каталогу с текстовыми файлами (не менее 100 файлов, 
каждый  из  которых  содержит  plain­text  объёмом  не  менее  100  слов).  Программа 
выполняет токенизацию (аналогично лаб. №1) и строит инвертированный индекс токенов 
(без приведения к словарной форме) всех файлов. Индекс хранится в оперативной памяти 
(SQL­подобные  базы  не  использовать!).  Затем  программа  в  цикле  получает  поисковый 
запрос, состоящий из одного или нескольких слов (ввод с клавиатуры ­ прерывание цикла 
и  выход  из  программы  осуществляется  по  вводу  пустого  запроса).  Для  введённого 
поискового  запроса  выполняется  поиск  документов  по  словоформам 
(словоупотреблениям) запроса. Результаты представляются в форме:  

```
“Номер результата”  “Имя файла” \n “текст предложений, в которых встречаются  слова запроса”
```

Поиск  и  ранжирование  результатов  должны  осуществляться  в  соответствии  с  Вашим 
вариантом. 
При  сдаче необходимо продемонстрировать  работу программы и пояснить принципы  её 
работы. 
В качестве текстов использовать загруженные документы из лаб №2.  

**Вариант №4:**

Реализовать алгоритм поиска так, чтобы найденые документы содержали все слова 
запроса,  причём  расстояние  между  ними  в  тексте  не  превышало  бы  заданного *N*  
(вводится с клавиатуры).

---------------------------------------------------------------------
### Подготовка данных

Для того, чтобы не нарушать условия задачи я переконвертировал записи из *sqlite* базы в набор текстовых файлов вида:  
```
# TITLE: <название статьи>

<текст статьи>
```


Из текста статьи (по понятным причинам) были удалены все HTML теги. В качестве названий файлов были изпользованы захешированные названия статей т.к. названия длиные и на русском языке, что порождает 2 проблемы: привышение максимально возможной длинны названия файла и проблемы с кирилицей в названиях.

Пример такого файла: **[Посмотреть файл тут](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/raw/-1597918585204509602)** / **[Как выглядит на habrahabr](http://habrahabr.ru/post/266399/)**  

```
#TITLE:Автоматическая сборка модулей ядра при помощи DKMS

      В некоторых случаях ручная сборка модулей ядра нецелесообразна, поскольку удобнее использовать Dynamic Kernel Module Support (DKMS) 
Технология DKMS позволяет в том числе производить автоматическую сборку модулей системы при обновлении ядра.
В данной статье рассматривается автоматическое управление при помощи DKMS на примере модулей шины CAN.
DKMS предполагает, что пакет модуля или совокупности модулей ядра располагается в директории /usr/src/{package_name}-{package-version}
Кроме исходных текстов модуля/модулей, директория пакета содержит конфиг dkms.conf, а также Makefile, в соответствии с которым производится сборка.
Создадим для DKMS пакета модулей шины CAN директорию /usr/src/can-dkms-4.1.6-200
Модули шины CAN расположены в двух различных поддиректориях исходников ядра: net/can
...
```  

Название скрипта: *raw_dumper.py*.

---------------------------------------------------------------------
### Ход решения

######Ввод

Допустимые значения:  
* Минимальное расстояние между словами = 1  
* Количество слов для поиска > 0  

![Ввод](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/input.png?raw=true)

######Чтение файлов

После ввода начинается работа алгоритма, будем поочередно перебирать файлы из дериктории ```raw```, выполнять поиск и
сразу выводить результат (если таковой имеется).

######Токенизация

Найдем статью с самым большим количеством токенов (учитывая знаки препинания):

```bash
$ wc -w raw/* | sed 's/\s\+/ /g' | cut -d ' ' -f2 | sort -nrk1 | head -2 | tail -1
13922
```

Как видно 13922 не такое большое количество токенов и следовательно можно смело обрабатывать всю статью целиком без разбиения.
После чтения каждого файла производим токенизацию, сегментацию и начинаем поиск.

######Поиск

Для начала опишу следующую концепцию расстояния между токенами: пусть у нас есть произвольная пара токенов ```(A,B)```
порядковые номера в множестве токенов будут равны ```P(A)``` и ```P(B)``` соответственно. Тогда расстояние между ними будет равно
```R(A,B)=|P(A)-P(B)|``` но стоит учитывать что ```|R(A,A)=R(B,B)=1|```. Обоснованно это следующим утверждением: Допустим у нас есть
токен стоящий в самом начале предложения, чтобы в него перейти необходимо совершить один переход, тогда рационально предположить, что
для перехода в любой токен необходимо совершить минимум один переход, даже если переход совершается из самого себя.
 *Данный подход используется в библиотеке анализа текста от Microsoft.*  

Общий ход алгоритма:  

* Итерируем по сегментам
    * Итерируем по токенам
        * Находим в тексте подпоследовательности состоящие из всех тредуемых слов:
            * Требуемый набор слов ```a b```
            * Максимальное расстояние ```2```
            * Текст ```a c b e a a b```
                * Полученный набор ``` ( (<1>a & <3>b) & (<5>a & <6>a & <7>b) )```
* Каждый полученный набор содержит все необходимые слова, выбираем самый короткий
* Итерируем выбранный набор с конца
    * Удаляем из списка требуемых слов текущее слово
    * Добавляем в новый список
    * Если список требуемых слов пуст возвращаем сформированный список
  
*Последнее действие необходимо для обрезания лишних слов с начала.*  

######Результат

![Example 1](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-1.png?raw=true)
![Example 2](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-2.png?raw=true)
![Example 3](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-3.png?raw=true)
![Example 4](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-4.png?raw=true)
![Example 6](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-6.png?raw=true)
![Example 7](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-7.png?raw=true)
![Example 8](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-8.png?raw=true)
![Example 9](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-9.png?raw=true)

Название скрипта: *search_words_in_range.py*.



