##Отчет по лабораторной работе №3
&nbsp; | &nbsp;
 --------------------- | ---------------------------------- 
**Предмет**            | *Методы интеллектуального поиска*   
**Выполнил**           | *Красюк Никита*                    
**Группа**             | *НК-401*                           
**Студенческий билет** | *103111130*  
                      
---------------------------------------------------------------------
### Постановка задачи
Реализовать программу индексации и поиска информации.
Программа получает на вход путь к каталогу с текстовыми файлами (не менее 100 файлов, 
каждый  из  которых  содержит  plain­text  объёмом  не  менее  100  слов).  Программа 
выполняет токенизацию (аналогично лаб. №1) и строит инвертированный индекс токенов 
(без приведения к словарной форме) всех файлов. Индекс хранится в оперативной памяти 
(SQL­подобные  базы  не  использовать!).  Затем  программа  в  цикле  получает  поисковый 
запрос, состоящий из одного или нескольких слов (ввод с клавиатуры ­ прерывание цикла 
и  выход  из  программы  осуществляется  по  вводу  пустого  запроса).  Для  введённого 
поискового  запроса  выполняется  поиск  документов  по  словоформам 
(словоупотреблениям) запроса. Результаты представляются в форме:  

```
“Номер результата”  “Имя файла” \n “текст предложений, в которых встречаются  слова запроса”
```

Поиск  и  ранжирование  результатов  должны  осуществляться  в  соответствии  с  Вашим 
вариантом. 
При  сдаче необходимо продемонстрировать  работу программы и пояснить принципы  её 
работы. 
В качестве текстов использовать загруженные документы из лаб №2.  

**Вариант №4:**

Реализовать алгоритм поиска так, чтобы найденные документы содержали все слова 
запроса,  причём  расстояние  между  ними  в  тексте  не  превышало  бы  заданного *N*  
(вводится с клавиатуры).

---------------------------------------------------------------------
### Подготовка данных

Для того, чтобы не нарушать условия задачи я переконвертировал записи из *sqlite* базы в набор текстовых файлов вида:  
```
# TITLE: <название статьи>

<текст статьи>
```


Из текста статьи (по понятным причинам) были удалены все HTML теги. В качестве названий файлов были использованы захешированные названия статей т.к. названия длиные и на русском языке, что порождает 2 проблемы: превышение максимально возможной длинны названия файла и проблемы с кириллицей в названиях.

Пример такого файла: **[Посмотреть файл тут](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/raw/-1597918585204509602)** / **[Как выглядит на habrahabr](http://habrahabr.ru/post/266399/)**  

```
#TITLE:Автоматическая сборка модулей ядра при помощи DKMS

      В некоторых случаях ручная сборка модулей ядра нецелесообразна, поскольку удобнее использовать Dynamic Kernel Module Support (DKMS) 
Технология DKMS позволяет в том числе производить автоматическую сборку модулей системы при обновлении ядра.
В данной статье рассматривается автоматическое управление при помощи DKMS на примере модулей шины CAN.
DKMS предполагает, что пакет модуля или совокупности модулей ядра располагается в директории /usr/src/{package_name}-{package-version}
Кроме исходных текстов модуля/модулей, директория пакета содержит конфиг dkms.conf, а также Makefile, в соответствии с которым производится сборка.
Создадим для DKMS пакета модулей шины CAN директорию /usr/src/can-dkms-4.1.6-200
Модули шины CAN расположены в двух различных поддиректориях исходников ядра: net/can
...
```  

Название скрипта: *raw_dumper.py*.

---------------------------------------------------------------------
### Ход решения

######Ввод

Допустимые значения:  
* Минимальное расстояние между словами = 1  
* Количество слов для поиска > 0  

![Ввод](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/input.png?raw=true)

######Чтение файлов

После ввода начинается работа алгоритма, будем поочередно перебирать файлы из директории ```raw```, выполнять поиск и
сразу выводить результат (если таковой имеется).

######Токенизация

Найдем статью с самым большим количеством токенов (учитывая знаки препинания):

```bash
$ wc -w raw/* | sed 's/\s\+/ /g' | cut -d ' ' -f2 | sort -nrk1 | head -2 | tail -1
13922
```

Как видно 13922 не такое большое количество токенов и следовательно можно смело обрабатывать всю статью целиком без разбиения.
После чтения каждого файла производим токенизацию, сегментацию и начинаем поиск.

######Поиск

Для начала опишу следующую концепцию расстояния между токенами: пусть у нас есть произвольная пара токенов ```(A,B)```
порядковые номера в множестве токенов будут равны ```P(A)``` и ```P(B)``` соответственно. Тогда расстояние между ними будет равно
```R(A,B)=|P(A)-P(B)|``` но стоит учитывать что ```|R(A,A)=R(B,B)=1|```. Обоснованно это следующим утверждением: Допустим у нас есть
токен стоящий в самом начале предложения, чтобы в него перейти необходимо совершить один переход, тогда рационально предположить, что
для перехода в любой токен необходимо совершить минимум один переход, даже если переход совершается из самого себя.
 *Данный подход используется в библиотеке анализа текста от Microsoft.*  

Общий ход алгоритма:  

* Итерируем по сегментам
    * Итерируем по токенам
        * Находим в тексте подпоследовательности состоящие из всех тредуемых слов:
            * Требуемый набор слов ```a b```
            * Максимальное расстояние ```2```
            * Текст ```a c b e a a b```
                * Полученный набор ``` ( (<1>a & <3>b) & (<5>a & <6>a & <7>b) )```
* Каждый полученный набор содержит все необходимые слова, выбираем самый короткий
* Итерируем выбранный набор с конца
    * Удаляем из списка требуемых слов текущее слово
    * Добавляем в новый список
    * Если список требуемых слов пуст возвращаем сформированный список
  
*Последнее действие необходимо для обрезания лишних слов с начала.*  

######Индексация

Для оптимизации скорости работы построим инвертированный поисковый индекс. Строить будем во время первого поискового
 запроса, это позволит не выносить индексацию в отдельный процесс. Хранить индекс будем в памяти,
  в виде структуры данных следующего вида:  
```python2.7
{
    "<word>": [<file_name_1>, <file_name_2>, ...],
}
```

Иными словами в виде словаря где ключи - это слова и каждому такому слову в соответствие ставится список 
 файлов в которых это слово встречается. Стоит заметить, что в списках будут храниться ссылки на названия файлов а не
 копии этих названий, таким образом, размер структуры зависит от количества уникальных слов в документах. Исходя из набора
 данных хранение подобной структуры в памяти позволительно.
 
При каждом дальнейшем поиске, поиск по конкретному файлу будет производиться только при условии, что документ содержит все слова поискового запроса.

Продемонстрируем на примере, насколько уменьшится время поиска благодаря инвертированному поисковому индексу:

![Example 1](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-1.png?raw=true)

Как видно до индексации длительность поиска занимает:  
```bash
-----LOG: Длительность поиска: 28.909 сек.
```

И после:

```bash
-----LOG: Длительность поиска: 1.669 сек.
```

Чем больше уникальных поисковых слов, тем быстрее поиск после индексации.  

До индексации:  
![Example 2](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-2.png?raw=true)

После индексации:  
![Example 3](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-3.png?raw=true)

```
28.650 сек -> 0.236 сек
```

######Результат

![Example 1](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-1.png?raw=true)
![Example 2](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-2.png?raw=true)
![Example 3](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-3.png?raw=true)
![Example 4](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-4.png?raw=true)
![Example 6](https://github.com/nikelsj11/Studying/blob/master/UniversityTasks/IntelligentSearch/TextSearch/_img/exp-6.png?raw=true)

Название скрипта: *search_words_in_range.py*.
