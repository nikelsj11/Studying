# Решение
``` creatives_selector.py ``` - файл с функцией решением  
``` _binary_heap.py ``` - файл с вспомагательным функционалом (структура данных binary heap)  
``` test.py ``` - тесты  
``` runner.py ``` - скрипт для консольного запуска  

## Пример работы  
``` $ python runner.py <input file> <number of winners> <country> ```   
```
$ python runner.py samples/sample_one 5 R
56	8	R
90	9	R
67	9	R
12	9	-
45	8	R
$ python runner.py samples/sample_one 5 R
56	8	R
89	8	R
90	9	R
67	9	R
12	9	-
$ python runner.py samples/sample_one 2 R
90	9	R
12	9	-
$ python runner.py samples/sample_one 2 R
90	9	R
67	9	R
$ python runner.py samples/sample_one 2 R
67	9	R
12	9	-
$ python runner.py samples/sample_two 4 R
32	99	-
96	6	-
45	7	-
56	6	R
$ python runner.py samples/sample_two 4 R
32	99	-
56	6	R
45	7	-
96	6	-
$ python runner.py samples/sample_long 10 R
64	9	R
66	9	R
43	9	R
36	9	R
38	9	R
41	9	R
75	9	R
49	9	R
89	9	-
29	9	R
$ python runner.py samples/sample_long 10 R
67	9	R
68	9	R
37	9	R
41	9	R
93	9	R
21	9	R
87	9	R
88	9	R
90	9	R
58	9	R

```

## Тестирование
```
$ python test.py
.......
----------------------------------------------------------------------
Ran 7 tests in 0.002s

OK
```

## Оптимизация
Задача очень просто решается в лоб. Но я провел несколько оптимизаций для повышения эффективности работы на выборках данных любой размерности. Во-первых, в начале необходимо отфильтровать данные по стране и заодно сформировать следующую структуру данных ```{ 'unique price': [creative_with_that_price_1, ...], ...}```, по сути это ```hash-table``` (встроенный ```dict```), где каждый ```key``` - уникальная стоимость а ```value``` - список creatives имеющих данную стоимость, все операции с ```dict``` выполняются за ```O(1)```, таким образом сложность операции в целом ```O(n)```.  Теперь можно получить список ключей ```dict``` (```O(1)```) и это будут уникальные стоимости, теперь задача сводится к последовательному получению максимумов массива уникальных стоимостей, для этого идеально подходит ```binary heap``` сложность подобной операции ```log(k)``` (если придется достать все стоимости ```k*log(k)```), где ```k``` - кол-во уникальных стоимостей, что понижает сложность задачи в разы, особенно учитывая меньший список для поиска.  После нахождения максимальной стоимости, получаем по ключу сущности из ```hash-table``` за ```O(1)``` и выбираем их в произвольном порядке. Для того чтобы ```advertiser_id``` не повторялись сохраняем результаты тоже в отдельный ```dict```, ```key``` - ```advertiser_id```, если ключ уже существует пропускаем, не существует добавляем с выбранным элементом в ```value```, все операции опять же за ```O(1)```. В конце объединяем все ```values```. В случае когда не выходит сформировать выборку необходимой длины отдаем ```None```.

## Samples
Формат семплов:  
```
<id> <price> <country>
53 7 USA
```
или
```
<id> <price>
53 7
```
